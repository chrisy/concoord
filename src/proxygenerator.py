import inspect, types, string
import os, shutil
import ast, _ast
from optparse import OptionParser

parser = OptionParser(usage="usage: %prog -m modulename -o objectname")
parser.add_option("-m", "--modulename", action="store", dest="modulename", help="name for the module (filename)")
parser.add_option("-o", "--objectname", action="store", dest="objectname", help="name for the object (class definition name)")
(options, args) = parser.parse_args()

INDENT = '    '

class ClientVisitor(ast.NodeVisitor):
    def __init__(self, objectname):
        self.objectname = objectname
        self.functions = {}
    
    def generic_visit(self, node):
        ast.NodeVisitor.generic_visit(self, node)

    def visit_ClassDef(self, node):
        if node.name == self.objectname:
            self.getfunctionsofclass(node)
        self.generic_visit(node)
    
    def visit_FunctionDef(self, node):
        self.generic_visit(node)

    def getfunctionsofclass(self, node):
        for functiondef in node.body:
            self.functions[functiondef.lineno] = functiondef

def createclientproxy(modulename, objectname):
    abspath = os.path.abspath(modulename+'.py')
    # Get the AST tree, find lines to fix
    astnode = compile(open(abspath, 'rU').read(),"<string>","exec",_ast.PyCF_ONLY_AST)
    v = ClientVisitor(objectname)
    v.visit(astnode)
    functions = v.functions
    # Get the contents of the file
    abspath = os.path.abspath(modulename+'.py')
    objectfile = open(abspath, 'r')
    oldfilecontent = {}
    i = 1
    for line in objectfile:
        oldfilecontent[i] = line
        i += 1
    numlines = i
    objectfile.close()
    # sort the dictionary by lineno
    functionlinenos = functions.keys()
    functionlinenos.sort()
    # We're going to iterate over the linenumbers, delete everything
    # in between and replace them with proxy-specific command.
    newlineno = 1
    newfilecontent = {}
    for lineno in range(1, numlines+1):
        if lineno < functionlinenos[0]:
            # We didn't reach the first function yet
            newfilecontent[newlineno] = oldfilecontent[lineno]
            newlineno += 1
        elif lineno in functionlinenos:
            # We need to replace code upto next functionlineno
            if functions[lineno].name == "__init__":
                newfilecontent[newlineno] = string.replace(oldfilecontent[lineno], "):", ", bootstrap):", 1)
                newlineno += 1
                newfilecontent[newlineno] = INDENT+INDENT+"self.proxy = ClientProxy(bootstrap)\n"
                newlineno += 1
                newfilecontent[newlineno] = functioncallstr(functions[lineno])
                newlineno += 1
            else:
                newfilecontent[newlineno] = oldfilecontent[lineno]
                newlineno += 1
                newfilecontent[newlineno] = functioncallstr(functions[lineno])
                newlineno += 1
    proxyfile = open(modulename+"proxy.py", 'w')
    proxyfile.write("#automatically generated by the proxygenerator\nfrom clientproxyonerun import *\n\n")
    for line, content in newfilecontent.iteritems():
        proxyfile.write(content)
    proxyfile.close()

def functioncallstr(function):
    argnames = []
    for arg in function.args.args:
        argnames.append(arg.id)
    return INDENT+INDENT+"self.proxy.invoke_command(\""+ function.name +"\", "+", ".join(argnames)+")\n\n"

def main():
    createclientproxy(options.modulename, options.objectname)
        
if __name__=='__main__':
    main()
