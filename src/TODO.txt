""" This file keeps the outstanding changes and thoughts we have about
paxi. """

*** CHANGES TO THE CODE ***

*** DONE ***
- Object needs to return values (not messages) --> clientproxy.py
- Don't resend every nonacked message, only resend messages when
a connection is recreated with a node.
- Failure Detector
- Garbage collection: acceptor state, safe commands
- self.lock problem: every msg_method function is called with the
lock, this might cause a problem in the perform core if it doesn't
return.
- DNSSERVER for openreplica.org
  -- Special Replicas: Listen to state, cannot become leader
  -- Keep dictionary of name to specialnode
  -- when asked for name, return specialnode
  -- specialnode handles metacommands like visible/invisible replicas
  -- specialnode responds to Aqueries with list of nodes
- DNSSERVER for group membership
  -- Make sure that the registerednames are up-to-date. We may need
  paxi to keep track of this -> A membership Object keeping track of
  recent Groups.
- clientgenerator.py -o bank 
	-- enumerate functions
	-- return new object -> bankclient.py
		--- when deposit is called it sends "deposit AccountID" to the leader
- adaptive resend
- noop commands
- External client to issue ADD NewReplica
- Leader proposes METACOMMAND ADDReplica
- if during leaderpromotion i find out that i should be a leader, i'll
send update message to everyone and collect decisions from everyone
- the update message has to carry decisions and executed
- Client has to switch to the new leader (it gets more than one leader
in the beginning and makes a list of them)
- graphs with standard deviation
- adaptive timeout for leader loop - LONGTIMEOUT/SHORTTIMEOUT
- check_leader_promotion has to take into account if the chosen leader
is ready to become a leader
- new replica should inherit state from a live replica
- new replica inherits connection state from live replica
  -- new replica sends helo to replicas it received from the bootstrap
  -- bootstrap shares acceptor set with a new replica (upon join)
- everyone pings the leader (failure monitoring and local failure detection)
- as Client doesn't send a HELO message to the Leader the nascentset
update has to happen in another way, otherwise the connection gets
lost
- when feeding in multiple requests to a client, client has to make
sure that all requests get replied. It shouldn't skip over a request
when it times out.
- multiple performs for the same command do not get
executed more than once
- NOT TO BE DONE: automatically take non-responsive peers out of the configuration
- do not let the commands get past the edge of the window
- configuration change meta-events
- nexttodecide is removed
- to find an eligible commandnumber look at *both* proposals and
decisions
- proposals keep things that have been proposed by a particular replica
- requests should be decisions
- when a new replica joins in, can make the system agree on an existing commandnumber
- replica only sends message to a client it has connection to
- if during PROPOSE we find out that our proposal is being overwritten
we propose it again (with a new commandnumber)
- there are lots of results returned in pvalues
- leader responds to a client only if the client is in its clientpool
- pmax doesn't work properly
- keep leader active, skip over the prepare phase
- ballot numbers seem to have gaps in them
- if a client re-sends a request, re-return the same old response
- execute meta commands when the window has passed
- automatic leader promotion
- client should time out if a request takes too long
- client commands get numbered by the leader
- client loop cleaned up, performs re-sends correctly, matches responses
- node does not deal with short reads
- commands are kept in (COMMANDSTATE,COMMAND) tuples
Leader & Acceptor	 : The replies for PREPARE and PROPOSE should
       	 		       	   have different names:
			       	       - MSG_PREPARE_ADOPTED
				       - MSG_PREPARE_PREEMPTED
				       - MSG_PROPOSE_ACCEPT
				       - MSG_PROPOSE_REJECT

Replica			 : 'requests' keeps
			           <commandnumber:(commandstate,command/result)> mappings
			  	   'commandstate' can be Executed,Decided,Running,None
				   		  - Executed: The command corresponding to the
			           		    	      	     commandnumber has been both decided
			                                             and executed.
						  - Decided: The command corresponding to the commandnumber
						    	     	     has been decided but it is not executed
			           				     yet (probably due to an outstanding
			           				     command prior to this command.)
						  - Running: The commandnumber is assigned to a command but the 
						    	     	     result is not known yet.
						  - None: The commandnumber has not been assigned to any command.
			  	   'nexttodecide' keeps the commandnumber that should be used for the next proposal
				   'nexttoexecute' keeps the commandnumber that has been executed

ResponseCollector    : 'received' keeps <peer:reply> mappings
		      	       	  upon receiving a reply the Response Collector adds it to 'received'
				  if a reply is coming for the second time it overwrites the old one
				  the length of 'received' determines if quorum is reached or not

Leader			  : 'proposals' keeps <commandnumber:proposal> mappings with the 
			  	   highest ballotnumber
				   Leader updates proposals by pMax(possiblepvalueset)
				   Leader goes over all proposals in this dictionary and sends a PROPOSE for each

Message			 : Command class to keep (clientid, clientcommandnumber, command)
			   	   triples. Will be used to prevent
			   	   double assignment of commands

Command		 : Used to keep clientid, clientcommandnumber and command triples, 
		   	   	   for disgarding multiple requests for the same command.
 
Replica                      :  Replica checks for every Command received if it has been executed 
			            before or not. Thus Replica keeps
			            state of commands.
Node		         : As messages may be received multiple times
			            outstandingmessages is indexed by
			            unique messageid's and multiple
			            copies of messages are discarded
			            not to affect state.

Leader		         : As messages may be received multiple times the ResponseCollectors 
                                   keep a list of acceptors that they are waiting a reply from and
                                   multiple replies are discarded for right behavior. 
   
Leader		         : global proposals and xor this with the pmaxset before sending commands 

Replica		    	  : Commands should be carried in a way that
			    	    the last replica/leader that gets
			    	    the command should be able to
			    	    respond to the client.

*** GRAPHS ***
- Performance: Throughput vs. number of Replicas
- Performance: Throughput vs. number of Acceptors
- Reliability: Throughput vs. failure events
- Reliability: Throughput in time
